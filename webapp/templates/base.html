<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}RedditVault{% endblock %}</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dark: {
                            900: '#0a0f1a',
                            800: '#0f172a',
                            700: '#1e293b',
                            600: '#334155',
                            500: '#475569',
                        }
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body class="bg-dark-900 text-gray-100 min-h-screen">
    <nav class="bg-dark-800 border-b border-dark-600 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 py-3">
            <div class="flex items-center justify-between">
                <a href="/" class="text-xl font-bold text-cyan-500">
                    RedditVault
                </a>
                <div class="flex items-center gap-4">
                    {% if current_user.is_authenticated %}
                    <form action="/search" method="GET" class="flex">
                        <input type="text" name="q" placeholder="Search..."
                               class="input-dark rounded-l px-3 py-1.5 text-sm w-48">
                        <button type="submit" class="btn-primary px-4 py-1.5 rounded-r text-sm">
                            Search
                        </button>
                    </form>
                    <div class="bg-dark-700 border border-dark-600 text-sm px-3 py-1 rounded-full">
                        <span id="stats" class="text-gray-300"></span>
                    </div>
                    <button id="sync-btn" onclick="triggerSync()"
                            class="sync-btn bg-dark-700 border border-dark-600 px-3 py-1.5 rounded text-sm hover:border-cyan-600 transition-colors">
                        Sync
                    </button>
                    <a href="/settings/api-keys" class="text-sm text-gray-400 hover:text-cyan-400 transition-colors">
                        API Keys
                    </a>
                    <span class="text-sm text-gray-400">u/{{ current_user.username }}</span>
                    <a href="{{ url_for('auth.logout') }}"
                       class="text-sm text-gray-400 hover:text-white transition-colors">
                        Logout
                    </a>
                    {% else %}
                    <a href="{{ url_for('auth.login') }}"
                       class="btn-primary px-4 py-2 rounded-lg text-sm font-medium">
                        Login with Reddit
                    </a>
                    {% endif %}
                </div>
            </div>
        </div>
    </nav>

    <!-- Flash messages -->
    {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
    <div class="max-w-7xl mx-auto px-4 pt-4">
        {% for category, message in messages %}
        <div class="flash-{{ category }} rounded-lg px-4 py-3 mb-2 text-sm">
            {{ message }}
        </div>
        {% endfor %}
    </div>
    {% endif %}
    {% endwith %}

    <main class="max-w-7xl mx-auto px-4 py-6">
        {% block content %}{% endblock %}
    </main>

    <script>
        {% if current_user.is_authenticated %}
        // Load stats
        function loadStats() {
            fetch('/api/stats')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('stats').textContent =
                        `${data.reviewed}/${data.total} reviewed`;

                    // Update sync button state
                    const syncBtn = document.getElementById('sync-btn');
                    if (data.sync_in_progress) {
                        syncBtn.classList.add('syncing');
                        syncBtn.textContent = 'Syncing...';
                        setTimeout(loadStats, 3000);
                    } else {
                        syncBtn.classList.remove('syncing');
                        syncBtn.textContent = 'Sync';
                    }
                });
        }
        loadStats();

        // Trigger sync
        function triggerSync() {
            const syncBtn = document.getElementById('sync-btn');
            syncBtn.classList.add('syncing');
            syncBtn.textContent = 'Syncing...';

            fetch('/api/sync', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({full: false})
            })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Sync error: ' + data.error);
                    syncBtn.classList.remove('syncing');
                    syncBtn.textContent = 'Sync';
                } else if (data.status === 'success') {
                    loadStats();
                    if (data.new_items > 0) {
                        location.reload();
                    }
                } else {
                    // Still running, poll for status
                    setTimeout(loadStats, 2000);
                }
            });
        }

        // Toggle reviewed state
        function toggleReviewed(itemId, btn) {
            const isReviewed = btn.dataset.reviewed === 'true';
            fetch(`/api/item/${itemId}/state`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({reviewed: !isReviewed})
            })
            .then(r => r.json())
            .then(data => {
                btn.dataset.reviewed = data.state.reviewed;
                const card = btn.closest('.item-card');
                if (data.state.reviewed) {
                    btn.textContent = 'Reviewed';
                    btn.classList.add('active');
                    card.classList.add('reviewed');
                } else {
                    btn.textContent = 'Mark Reviewed';
                    btn.classList.remove('active');
                    card.classList.remove('reviewed');
                }
                loadStats();
            });
        }

        // Unsave item from Reddit
        function unsaveItem(itemId, btn) {
            if (!confirm('Unsave this item from Reddit? This cannot be undone.')) {
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Unsaving...';

            fetch(`/api/item/${itemId}/unsave`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                    btn.disabled = false;
                    btn.textContent = 'Unsave';
                } else {
                    // Remove the card with animation
                    const card = btn.closest('.item-card');
                    card.style.opacity = '0';
                    card.style.transform = 'translateX(100px)';
                    card.style.transition = 'all 0.3s ease';
                    setTimeout(() => {
                        card.remove();
                        loadStats();
                    }, 300);
                }
            })
            .catch(err => {
                alert('Error: ' + err);
                btn.disabled = false;
                btn.textContent = 'Unsave';
            });
        }
        {% endif %}
    </script>
</body>
</html>
